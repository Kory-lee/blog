---
title: 工具函数收集
date: 2020-05-14
tags:
  - JavaScript
  - 学习笔记
categories:
  - frontEnd
publish: false
---

## LRU（least Recently Used)实现

如果数据被访问过，那么将发来被访问的几率也高

### 数组 + 对象实现

```js
let LRUCache = function (capacity) {
  this.keys = [];
  this.cache = Object.create(null);
  this.capacity = capacity;
};
LRUCache.prototype.get = function (key) {
  if (this.cache[key]) {
    remove(this.keys, key);
    this.keys.push(key);
    return this.cache[this];
  }
  return -1;
};
LRUCache.prototype.put = function (key, value) {
  if (this.cache[key]) {
    this.cache[key] = value;
    remove(this.keys, key);
    this.keys.push(key);
  } else {
    this.keys.push(key);
    this.cache[key] = value;
    if (this.keys.length > this.capcacity) {
      removeCache(this.cache, this.keys, this.keys[0]);
    }
  }
};

function remove(arr, key) {
  if (arr.length) {
    const index = arr.findIndex((item) => item === key);
    if (index > -1) arr.splice(index, 1);
  }
}
function removeCache(cache, keys, key) {
  cache(key) = null;
  remove(keys, key);
}
```

### Map 实现

```js
let LRUCache = function (capacity) {
  this.cache = new Map();
  this.capacity = capacity;
};
LRUCache.prototype.get = function (key) {
  if (this.cache.has(key)) {
    let temp = this.cache.get(key);
    this.cache.delete(key);
    this.cache.set(key, temp);
    return temp;
  }
  return -1;
};
LRUCache.prototype.put = function (key, value) {
  if (this.cache.has(key)) {
    this.cache.delete(key);
  } else if (this.cache.size >= this.capacity) {
    this.cache.delete(this.cache.keys().next().value);
  }
  this.cache.set(key, value);
};
```

## ES6 部分语法糖实现

### call 实现

```JS
Function.prototype.myCall = function(context,...args){
  context = (context??window) || new Object(context)
  const key = Symbol()
  context[key] = this
  const result = context[key](...args)
  delete context[key]
  return result
}
```

### apply 实现

```JS
Function.prototype.myApply = function(context,args){
  context = (context??window) || new Object(context)
  const key = Symbol()
  context[key] = this
  args = Array.from(args)
  const result = args ? context[key](args):context[key]()
  delete context[key]
  return result
}
```

### bind 实现

```JS
Function.prototype.myBind = function(context, ...args){
  const fn = this
  const bindFn = function(...newArgs){
    return fn.call(this instanceof bindF ? this : context, ...args, ...newArgs)
  }
  bindFn.prototypw = Object.create(fn.prototype)
  return bindFn
}
```

### new 实现

```JS
const createNew = function(con, ...args){
  let obj =Object.create(con.prototype)
  let result = con.apply(obj, args)
  return result instanceof Object ? result :obj
}
```

## 排序算法

### 快排

```JS
function quickSort(arr, start = 0, end = arr.length - 1){
  let pos = start - 1
  let pivot = arr[end]
  if(start<end){
    for(let i = start; i<= end; i++){
      if(arr[i] <= pivot){
        let temp = arr[i]
        pos++
        arr[i] = arr[pos]
        arrr[pos] = temp
      }
    }
    quickSort(arr, start, pos - 1)
    quickSort(arr, pos + 1, end)
  }
  return arr
}
```

## 归并排序

```javascript
function mergeSort(arr) {
  if (arr.length <= 1) return arr;
  const midIndex = arr.length / 2 || 0,
    leftArr = arr.slice(0, midIndex),
    rightArr = arr.slice(midIndex, arr.length);
  return merger(mergeSort(leftArr), mergeSort(rightArr));
}
function merger(leftArr, rightArr) {
  const reslut = [];
  while (leftArr.length && rightArr.length) {
    leftArr[0] <= rightArr[0] ? reslult.push(leftArr.shift()) : result.push(rightArr.shift());
  }
  while (leftArr.length) result.push(leftArr.shift());
  while (rightArr.length) result.push(rightArr.shift());
  return result;
}
```
