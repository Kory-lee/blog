---
title: 事件轮询模型
date: 2020-04-03
tags:
  - Js
  - 学习笔记
categories:
  - frontEnd
---

## 进程与线程

### 进程

程序的一次运行,它占有一片独有的内存空间

### 线程(thread)

- 是进程内的一个独立执行单元
- 是程序运行的一个完整流程
- 是 CPU 的最小调度单元

### 相关知识

- 应用程序必须运行在某个进程的某个线程上
- 一个进程中至少有一个运行的线程: 主线程, 进程启动后自动创建
- 一个进程中也可以同时运行多个进程, 我们会说程序是多线程运行的
- 一个进程内的数据可以供其中的多个进程直接共享
- 多个进程之间的数据是不能共享的
- 线程池(thread pool):保存多个线程对象的容器,实现对象的反复利用

多进程:一个应用程序可以同时启动多个实例进行

多线程:一个进程内,可以有多个线程进行

## 浏览器内核由很多模块组成

- 主线程
  - `js`引擎模块:负责 js 程序的编辑和运行
  - html,css 文档解析模块:负责页面文本的解析
  - DOM/CSS 模块;负责`dom`/`css`在内存中的相关处理
  - 布局和渲染模块:负责页面的布局和效果的绘制(内存中的对象)
- 分线程
  - 定时器模块:负责定时器的管理
  - `DOM`事件响应模块:负责事件的管理
  - 网络请求模块:负责 ajax 请求

### 单线程执行的`js`

#### 怎么证明

- `setTimeout()`的回调函数是主线程执行的
- 定时器回调函数只有在执行栈中的代码全部执行完后才有可能执行

#### 为什么

- 作为浏览器脚本语言,`javaScript`的主要用途是和用户互动,及操作 DOM
- 这决定了它只能是单线程,否则会带来很复杂的问题

#### 代码的分类

- 初始化代码
- 回调代码

#### `Js`引擎执行代码的基本流程

- 先执行初始化代码: 包含一些特殊的代码
  - 设置定时器
  - 绑定监听
  - 发送 ajax 请求
- 后面在某个时刻才会执行回调函数

## 事件循环模型

### 所有代码分类

- 初始化和执行代码(同步代码)：包含绑定`dom`事件监听，设定定时器，发送 ajax 请求的代码
- 回调执行代码(异步代码)：处理回调函数

### `js`引擎执行代码的基本流程

- 初始化代码==>回调代码

### 模型的 2 个重要的组成部分:

- 事件（定时器/DOM 事件）管理模块
- 回调队列

### 模型的运转流程

- 执行初始化代码，将事件回调函数交给对应模块管理
- 当事件发生时，管理模块会将回调函数及其数据添加到回调队列中
- 只有当初始化代码执行完后（可能要一定时间），才会遍历读取回调队列中的回调函数执行

### 模型原理图

![事件轮询](/img/event-loop.png)

- 事件轮询(event loop)
  - 从任务队列中循环取出回调函数放入执行栈中处理(一个接一个)
  - 一个事件循环存在多个任务源,这确保了任务在特定任务源的执行顺序(**同一个任务源的任务才会被添加到相同的任务队列**),但在每一次的循环中,浏览器会自主选择哪个源的任务优先执行,这就确保了一些性能敏感的任务的优先级,比如用户输入
- 任务(task)
  - 被放到任务源中,浏览器内部执行转移到 javascript/DOM 领域,并确保按顺序执行
- 微任务(Micro tasks)
  - 这些任务应该在正在执行的脚本之后立即执行,比如对一些动作进行反应，或者操作异步执行避免整个新任务造成的性能浪费。微任务在其他没有 JavaScript 运行并且 task 执行完毕后执行，

#### 相关重要概念

1. 执行栈
   1. execution stack
   2. 所有的代码都是在此空间中执行的
2. 请求响应模型(request-response model)
