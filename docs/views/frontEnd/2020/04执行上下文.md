---
title: 执行上下文
date: 2020-04-03
tags:
  - JavaScript
  - 学习笔记
categories:
  - frontEnd
publish: false
---

## 执行上下文

1. 全局执行上下文

   - 在执行全局代码前将 window 确定为全局执行上下文
   - 对全局数据进行预处理
     - `var`定义的全局变量==>`undefined`,添加为 window 的属性
     - function 声明的全局函数==>赋值,添加为 window 方法
     - this ==>赋值(window)

2. 函数执行上下文
   - 在**调用函数**前,准备执行函数体前,创建对应的<span style="border-bottom:2px solid blue;">函数执行上下文对象</span>(虚拟,存在于栈中)
   - 对局部数据进行预处理
     - 形参变量-->赋值(实参)-->添加为执行函数上下文的属性
     - arguments(伪数组) ==>赋值（实参列表）,添加为执行函数上下文的属性
     - `var`定义的局部变量==>`undefined`，添加为执行函数上下文的属性
     - `function`声明的函数==>赋值(fun), 添加为执行函数上下文的方法
     - this==>赋值(调用函数的对象)
   - 开始执行代码
3. Eval 函数执行上下文: 执行在`eval`函数内部的代码也会有属于自己的执行上下文。

```js
var c = 1;
function c(c) {
  //变量提升要优先于函数提升
  console.log(c);
  var c = 3;
}
c(2); //报错
```

## 执行上下文栈

1. 在全局代码执行前,`js`引擎就会创建一个栈来存储管理所有的执行上下文对象
2. 在全局执行上下文(window)确定后,将其添加到栈中(压栈)
3. 在函数执行上下文创建后,将其添加入栈中(压栈)
4. 在函数执行完后,将栈顶的对象移除(出栈)
5. 当所有的代码执行完后,栈中只剩 window

## 执行上下文的创建

- 创建阶段(The Creation Phase)
  1. 创建词法环境(`LexicalEnviroment`)
  2. 创建变量环境(`VariableEnviroment`)

因此执行上下文在概念上应该是这样的

```ts
ExecutionContext = {
  /*变量对象加上父级上下文的变量对象*/
  LexicalEnviroment = <ref. to LexicalEnviroment in memory>,
  /*函数的参数,内部的方法变量声明*/
  VariableEnviroment = <ref. to VariableEnviroment in memory>,
  ThisBinding = <this value>
}
```

### 词法环境(LexicalEnviroment)

词法环境是 ECMA 中的一个规范类型 --基于代码词汇嵌套结构来记录标识符 和具体变量或函数的关联。简单来说，词法环境就是建立了标识符--变量的映射表。这里的标识符指的是变量名称或函数名，而变量则是实际变量原始值或对象、函数的引用地址。

词法环境中由三个部分组成

- 环境记录`EnvironmentRecord`: 存放变量和函数声明的地方
- 外层调用`outer`: 提供了访问父词法环境的引用,可能为 null
- this 绑定`ThisBinding`: 确定当前环境 this 的指向

#### 词法环境的类型

- 全局环境(`GlobalEnvironment`): 在 JavaScript 代码运行开始宿主（浏览器，node 等）会事先初始化全局环境，在全局环境的`EnvironmentRecord`中会绑定内置对象(Infinity 等)或全局函数(eval、parseInt 等)，其他声明的全局变量或函数也会储存在全局词法变量中。全局环境的`outer`引用为`null`

:::tip
全局对象包含所有内置对象，如 Math、Object、Array 等构造函数，以及 Infinity 等全局变量。全局函数则包含了 eval、parseInt 等函数。
:::

- 模块环境(`ModuleEnvironment`): 在模块环境中可以读取到`export`、`module`等变量, 这些变量都记录在模块环境的 ER 中。模块环境的`outer`引用指向全局环境。
- 函数环境(`FunctionEnvironment`): 每一次调用函数时都会产生函数环境, 在函数环境中会涉及`this`的绑定或者`super`的调用.在 ER 中也会记录该函数的`length`和`arguments`属性。函数环境的`outer`引用指向调用函数的父环境。在函数体内声明的变量或声明记录在函数环境中

#### 环境记录 ER

代码中声明的变量和函数都会存放在`EnvironmentRecord`中等待执行时访问。ER 也有两个不同类型，分别是`declarative`和`object`。`declarative`是较常见的类型，通常函数声明、变量声明(`var const let class module import`等)都会生成这种类型的 ER。`object`类型可以由`with`触发，而`with`使用场景很少。
:::warning 注意
全局上下文的`ER`有点特殊,因为它是`object ER`和`declarative ER`的混合体。在`object ER`中存放的是全局对象函数、`function`函数声明、`async`、`generator`、`var`关键词变量。在`declarative ER`则存放其他方式声明的变量,如`let const class`等.由于标准中将`object`类型的 ER 视作基准 ER, 因此这里我们仍可以将全局 ER 的类型视作`object`

```js
GlobalExecutionContext = {
  LexicalEnvironment:{
    type: 'object',  // 混合 object + declarative
    NaN,
    parseInt,
    Object,
    myFunc,
    a,
    b,
    ...
  },
  outer: null,
  this: <globalObject>
}
```

:::

## 作用域和执行上下文

1. 区别 1
   1. 全局作用域之外,每个函数都会创建自己的作用域,作用域在函数定义之后就已经确定,而不是在函数调用时
   2. 全局执行上下文环境是在全局执行上下文确定之后,js 代码马上执行之前创建
   3. 函数执行上下文环境是在调用函数时,函数体代码执行之后创建
2. 区别 2
   1. 作用域是静态的,只要函数定义好了就一直存在,且不会再变化
   2. 上下文环境是静态的,调用函数时创建,函数调用结束后上下文环境就会被自动释放
3. 联系
   1. 上下文环境(对象)是从属于所在的作用域
   2. 全局上下文环境==>全局作用域
   3. 函数执行上下文环境==>对应的函数使用域

```js
var x = 10;
function fn() {
  console.log(x);
}
function show(f) {
  var x = 20;
  f();
}
show(fn); //10
```
