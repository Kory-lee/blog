---
title: HTTP请求过程
date: 2020-06-18
tags:
  -
categories:
  - frontEnd
---

## 一. HTTP 请求和响应步骤

![理解 HTTP 请求与响应](/img/06/HTTP.webp)

## 二. TCP/IP 协议

TCP/IP 协议模型(Transmission Control Protocol/Internet Protocol),包含了一系列构成互联网基础的网络协议,是 Internet 的核心协议。
TCP/IP 协议簇是一组不同层次上的多个协议的组合，通常被认为是一个四层协议系统，与 OSI 的七层模型相对应

HTTP 协议就是基于 TCP/IP 协议模型来传输信息的

![img](/img/06/TCP_IP协议.webp)

1. 链路层
   - 也称作数据链路层或网络接口层,通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。他们一起处理与电缆（或其他任何传输媒介）的物理接口细节。ARP（地址解析协议）和 RARP（逆地址解析协议）是某些网络接口使用的特殊协议，用来转换 IP 层和网络接口层使用的地址
2. 网络层
   - 处理分组在网络中的活动，例如分组的选路。在 TCP/IP 协议族中，网络层协议包括 IP 协议（网际层协议），ICMP 协议（internet 互联网控制报文协议），以及 IGMP 协议（Internet 组管理协议）
   - IP 是一种网络层协议，提供的是一种不可靠的服务，它只是尽可能快地把分组从源节点送到目标节点，但不提供任何可靠性保证。同时被 TCP 和 UDP 使用。TCP 和 UDP 的每组数据都通过端系统和每个中间路由器中的 IP 层在互联网中进行传输
   - ICMP 是 IP 协议的附属协议。IP 层用它来与其他主机或路由器交换错误报文和其他重要信息。
   - IGMP 是 Internet 组管理协议。它用来把一个 UDP 数据报多播到多个主机。
3. 传输层
   - 主要为两台主机上的应用程序提供端对端的数据通信。在 TCP/CP 协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和 UDP（用户数据报协议）
   - TCP 为两台主机提供高可靠性的数据通信，它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接受到的分组，设置发送最后确认分组的超时时钟等。由于运输车提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。为了提高可靠的服务，TCP 采取了超时重传、发送和接受端到端的确认分组等机制
   - UDP 则为应用层提供一种非常简单的服务。他只是把称作数据报的分组从一台主机传送到另一台主机，但并不保证该数据报能到达另一端。一个数据包是指从发送方传输到接收方的一个信息单元。UDP 协议任何必须的可靠性必须由应用层来提供
4. 应用层

   - 应用层决定了像用于童工应用服务时贴心的 3 活动。TCP/IP 协议族内渔村了各类通用的应用服务。包括 HTTP，FTP（File Transfer Protocol，文件传输协议），DNS（Domain Name System，域名系统）服务

![TCP](/img/06/TCP.png)

当应用程序用 TCP 传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息。

当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接受数据的上层协议。这个过程称作分用（Demultiplexing）。协议是通过目的端口号、源 IP 地址和源端口号进行解包的

![HTTP请求与访问](/img/06/HTTP请求与响应.webp)

## 三、TCP 三次握手

TCP 是面向连接的，无论哪一方面向另一方发送数据之前，都必须现在双方之间建立一个链接。在 TCP/IP 协议中，TCP 协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP 窗口大小信息

![三次握手](/img/06/TCP三次握手.webp)

1. 第一次握手：建立连接。客户端发送连接请求报文段，将 SYN 位置为 1，Sequence Number 为 x；然后客户端进入 SYN_SEND 状态，等待服务器的确认
2. 第二次握手：服务器接收到 SYN 报文段。然后对这个 SYN 报文段进行确认，设置 Acknowledgment Number 为 x+1（Sequence Number + 1）；同时，自己还要发送 SYN 请求信息，将 SYN 位置为 1，Sequence Number 为 y；服务器将上述所有信息放到一个报文段（即 SYN+ACK 报文段）中，一并发送给客户端，此时服务器进入 SYN_RECV 状态
3. 第三次握手：客户端接收到服务器的 SYN+ACK 报文段。然后将 Acknowledgment Number 设置为 y+1，向服务器发送 ACK 报文段，这个报文段发送完毕之后，客户端和服务端都进入 ESTABLISHED 状态，完成 TCP 握手。

:::tip 为什么要三次握手
为了防止已失效的连接请求报文段突然有传送到了服务器，因而产生错误。

其次，在实际的通信中，序号并不是从 1 开始的，而是需要随机数计算出一个初始值，这是因为如果序列号都从 1 开始，通信过程就会非常容易预测，有人会利用这一点来发动攻击

:::

## 四、HTTP 协议

通俗的讲，他就是计算机通过网络进行通信的规则，是一个基于**请求与响应**、**无状态的**、**应用层**的协议，常基于**TCP/IP**此协议传输数据。

四个基于：

- 请求与响应：客户端发送数据，服务单响应数据
- 无状态的： 协议对于事务处理没有记忆能力，客户端第一次与服务器建立连接发送请求时需要进行一系列的安全认证匹配等，因此增加页面等待时间，当客户端向服务器端发送请求，服务端响应完毕后，两者断开连接，也不保存状态。
- 应用层： HTTP 是基于应用层的协议，配合 TCP/IP 使用
- TCP/IP: HTTP 使用 TCP 作为他的支撑运输协议。HTTP 客户机发起一个与服务器的 TCP 连接，一旦建立链接，浏览器（客户机）和服务器进程就可以通过接口访问 TCP

:::tip 针对无状态的一些解决策略
有时需要对用于之前的 HTTP 通信状态进行保存，比如执行一次登陆操作，在 30 分钟内所有的 ing 求都不需要再次登录。于是引入了 Cookie 技术

HTTP/1.1 想出了持久连接（HTTP keep-alive）方法，其特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态，在请求首部字段中的 Connecion：keep-alive 即为表明使用了持久连接
:::

## 五、HTTP 请求报文

HTTP 是面向文本的，报文中的每一个字段都是一些 ASCII 码串，各个字段的长度都是不确认的。HTTP 有两类报文：请求报文和响应报文。

由请求行（request line）、请求头部（header）、空行和请求数据 4 个部分组成
![请求报文](/img/06/请求报文.webp)

- 请求方法
  HTTP/1.1 定义的请求方法有 8 种：get、post、put、delete、patch、head、options、trace
- 请求地址
  url： 资源定位符，是一种资源位置的抽象唯一识别方法
  <协议>://<主机>:<端口>/<路径>
- 请求头部
  请求头部为请求报文添加了一些附加信息
  ![请求头部](/img/06/请求头部.webp)

  **请求头部最后会有一个空行，表示请求头部结束，接下来为请求数据，这一步非常重要，必不可少。**

## 六、HTTP 响应报文

![响应报文](/img/06/响应报文.webp)
状态代码

- 1xx：指示信息--表示请求已接收，继续处理。
- 2xx：成功--表示请求已被成功接收、理解、接受。
- 3xx：重定向--要完成请求必须进行更进一步的操作。
- 4xx：客户端错误--请求有语法错误或请求无法实现。
- 5xx：服务器端错误--服务器未能实现合法的请求。

响应头部

![响应头部](/img/06/响应头部.webp)

响应数据

数据已经传递完毕，HTTP/1.1 会维持持久连接，但持续一段时间总会有关闭连接的时候，这时候据需要断开 TCP 连接。

## 七、TCP 四次挥手

![四次挥手](/img/06/四次挥手.webp)

- 第一次挥手：主机 1（客户端或服务端），设置 Sequence Number，向主机 2 发送一个 Fin 报文段；此时，主机 1 进入 FIN_WAIT_1 状态
- 第二次挥手：主机 2 收到了主机 1 发送的 FIN 报文段，向主机 1 回一个 ACK 报文段，Acknowledgment Number 为 Sequence Number 加 1；主机 1 进入 FIN_WAIT_2 状态；主机 2 告诉主机 1，我“同意”你的关闭请求；
- 第三次挥手：主机 2 向主机 1 发送 FIN 报文段，请求关闭连接，同时主机 2 进入 LAST_ACK 状态；
- 第四次挥手：主机 1 收到主机 2 发送的 FIN 报文段，向主机 2 发送 ACK 报文段，然后主机 1 进入 TIME_WAIT 状态；主机 2 收到主机 1 的 ACK 报文段以后，就关闭连接；此时，主机 1 等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机 1 也可以关闭连接了。

:::tip 为什么要四次挥手
TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当主机 1 发出 FIN 报文时，只是表示主机 1 没有数据要发送了，主机 1 告诉主机 2，他的数据已经全部发送完毕了；到那时，这个时候主机 1 还是可以接受主机 2 的数据；当主机 2 返回 ACK 报文时，表示他已经知道主机 1 没有数据发送了，但是主机 2 还是可以发送数据到主机 1 的；当主机 2 也发送了 FIN 报文段时，这个时候就表示主机 2 也没有数据要发送了，就会告诉主机 1，我也没有数据要发送了，之后彼此就会愉快的中断这次 TCP 连接。
:::

## 八、TLS 握手：HTTPS 的核心

![TLS](/img/06/TLS.webp)

### 何时发生

1. 每当用户通过 HTTPS 导航到网站并且浏览器首先来时查询网站的原始服务器时，就会进行 TLS 握手
2. 每当其他任何通信使用 HTTPS（包括 API 调用和 HTTPS 查询上的 DNS)时，也会发生 TLS 握手
3. 通过 TCP 握手打开 TCP 连接后，会发生 TLS 握手

![TLS加密](/img/06/TLS握手.webp)
