---
title: Js内置对象属性和方法汇总
date: 2020-04-05
tags:
  - Js
  - 学习笔记
categories:
  - frontEnd
---

## JS 三大对象

JavaScript 有三大对象,分别是**本地对象**、**内置对象**和**宿主对象**。
引用 ECMA-262（ECMAScript 的制定标准）的定义

- 本地对象
  - 与宿主无关,独立于宿主环境的 ECMAScript 实现提供的对象
  - 简单来说,本地对象就是 ECMA-262 定义的类(引用类型)
  - 这些引用类型在运行过程中需要通过 new 来创建所需的实例对象
  - 包含 Object、Array、Data、RegExp、Function、Boolean、Number、String 等
- 内置对象
  - 与宿主无关,独立于宿主环境的 ECMAScript 实现提供的对象
  - 在 ECMAScript 程序开始执行前就存在，本身就是实例化内置对象，开发者无需再去实例化
  - 内置对象是本地对象的子集
  - 包含 Global 和 Math
  - ECMAScript5 增添了 JSON 这个全局的内置对象
- 宿主对象
  - 由 ECMAScript 实现的宿主环境提供的对象，包含两大类，一个是宿主提供，一个是自定义对象
  - 所有非本地的对象都属于宿主对象
  - 对于嵌入到网页中的 js 来说，其宿主对象就是浏览器提供的对象，浏览器对象有很多，如 Window 和 Document 等
  - 所有的 DOM 和 BOM 对象都属于宿主对象

::: theorem 关于专业名词
本地对象也经常被叫做原生对象或内部对象，包含 Global 和 Math 在内的内置对象在《JavaScript 高级程序设计》里也被叫做单体内置对象，很多时候，干脆也会直接把本地对象和内置对象统称为“内置对象”，也就是说除了宿主对象，剩下的都是 ECMAScript 的内部的“内置”对象。

声明：本文也将采取这种统称为“内置对象”的方式，比如文章标题。
:::

## Object 类型

### 实例方法

#### 1. toString()

功能:返回当前对象的字符串形式,返回值为 String 类型

```js
[1,'2',true],toString() // "1,2,true"
(new Date()).toString()//"Sun Apr 05 2020 22:31:31 GMT+0800 (中国标准时间)"
({name: 'kory'}).toString() //"[object Object]"
132.toString()// Uncaught SyntaxError: Invalid or unexpected token(123.被识别为小数点)
123..toString()// "123"
```

:::tip
该方法属于 Object 对象，由于所有的对象都“继承”了 Object 的对象实例，因此几乎所有的实例对象都可以使用该方法
JavaScript 的所有内置对象都重写了该函数，以实现更适合自身的功能需要
:::

#### 2. `toLocaleString()`

功能: 返回当前对象的"本地化"字符串形式，以便于当前环境的用户辨识度和使用，返回值为 String 类型。

```js
(1234567).toLocaleString(); //"1,234,567"
(6.37588).toLocaleString(); //"6.376"
new Date().toLocaleString(); //"2017/9/24 下午2:58:21"
```

#### 3. `valueOf()`

功能: 返货指定对象的原始值

> JavaScript 的许多内置对象都重写了该函数，以实现更适合自身的功能需要。因此，不同类型对象的 valueOf()方法的返回值和返回值类型均可能不同。

### 静态方法

#### 1. Object.assign(target,...source) <span style={color: "red"}>钱拷贝</span>

功能: 把一个或多个愿对小的可枚举、自由属性复制到目标对象中，返回值为目标对象
参数：

- 目标对象（必须）
- 至少一个源对象（可选）

```js
let target = { a: 1 };
let object2 = { b: 2 };
let object3 = { c: 3 };
Object.assign(target, object2, object3);
// 第一个参数是目标对象，后面的参数是源对象
target; // {a: 1, b: 2, c: 3}
```

#### 2. Object.create(proto[,propertiesObject])

功能: 创建一个对象,其原型为 prototype,同时可添加多个属性
参数:

- proto(必填):原型对象,可以为 null 表示没有原型。
- descriptors(可选)： 包含一个或多个属性描述符的对象
  propertiesObject 参数详解
- 数据属性
  - value：值
  - writable：是否可修改属性的值
  - configurable：是否可以通过 delete 删除属性，重新定义
  - enumerable：是否可 for...in 枚举
- 访问属性
  - get(): 访问
  - set(): 设置
    > 总结: Object.create()是 ES5 中提出来的一种新的对象创建方式，第一个参数是要继承的原型，如果不是一个子函数，可以传一个 null，第二个可选参数是对象的属性描述符

#### 3. `Object.defineProperty(obj,prop,descriptor)`

功能: 在一个对象上定义一个新属性或修改一个现有属性,并返回该对象
参数:

- obj(必须):被操作的目标对象
- prop(必须): 被定义或被修改的目标属性
- descriptor(必须):属性的描述符
  > 总结: 在参数 descriptor 中,如果不指定 configurable, writable,enumerable, 则这些属性默认值为 false,如果不指定 value,get,set,则这些属性默认值为 undefined

#### 4. `Object.defineProperties(obj,props)`

功能: 在一个对象定义一个或多个新属性或修改现有属性,并返回该对象
参数:

- obj(必须):被操作的目标对象
- props(必须): 该对象的一个或多个键值对定义了将要为对象添加或修改的属性的具体配置

```js
var obj = {};
Object.defineProperties(obj, {
  name: {
    writable: true,
    configurable: true,
    enumerable: false,
    value: '张三'
  },
  age: {
    writable: true,
    configurable: true,
    enumerable: true,
    value: 23
  }
});
```

#### 5. `Object.is(value1,value2)`

功能: 用来比较两个值是否严格相等,与(===)基本类似

```js
Object.is('q', 'q'); // true
Object.is(1, 1); // true
Object.is([1], [1]); // false
Object.is({ q: 1 }, { q: 1 }); // false
// 与(===)的区别
Object.is(-0, +0) - // false
  0 ===
  +0; // true
Object.is(NaN, NaN); //true
NaN === NaN; // false
```

#### 6.`Object.seal(obj)/Object.isSealed(obj)`

功能: 密封对象阻止其修改现有属性的配置特性，即将对象的所有属性的 configurable 特性设置为 false（也就是全部属性都无法配置，唯独可以把 writable 的值 true 改为 false，即冻结属性），并阻止添加新属性，返回新对象

参数：

- obj(必须):被密封的对象

```js
var obj = { name: '张三' };
Object.seal(obj);
Object.isSealed(obj);
obj.name = '李四'; //修改值成功
console.log(obj.name); //'李四'
obj.age = 23; //无法添加新属性
console.log(obj.age); //undefined
Object.defineProperty(obj, 'name', {
  writable: true,
  configurable: true,
  enumerable: true
}); //报错：Cannot redefine property: name
```

补充: Object.isSealed(obj)用来判断目标对象是否被密封,返回布尔值
:::tip
将一个对象密封后仅能保证该对象不被扩展且全部属性不可重新配置, 但是原属性值却可以被修改
:::

#### 7. Object.freeze(obj)/Object.isFrozen(obj)

功能: 完全冻结对象,在 seal 的基础上,属性值也不可修改,即每个属性的 writable 也被设为 false

参数:

- obj(必须): 被冻结的对象

#### 8. `getOwnPropertyDescriptor(obj,prop)`

功能: 获取目标对象上某自由属性的配置特性(属性描述符)，返回值为配置对象

参数：

- obj（必须）：目标对象
- prop（必须）：目标自有属性

```js
var obj = {};

Object.defineProperty(obj, 'name', {
  writable: true,
  configurable: false,
  enumerable: true,
  value: '张三'
});

var prop = Object.getOwnPropertyDescriptor(obj, 'name');
console.log(prop); //{value: "张三", writable: true, enumerable: true, configurable: false}
```

#### 9. `getOwnPropertyName(obj)`

功能:获取目标对象上的全部自有属性(包括不可枚举属性)组成的数组

参数:

- obj(必须):目标对象

```js
ar obj = {};
obj.say = function(){};
Object.defineProperties(obj,{
    name:{
      writable: true,
      configurable: true,
      enumerable: true,
      value: '张三'
    }
});
var arr = Object.getOwnPropertyNames(obj);
console.log(arr); //["say", "name"]
```

#### 10. `Object.getPrototypeOf(obj)`

功能: 获取指定对象的原型, 即目标对象的 prototype 属性的值

参数:

- obj(必须):目标对象

```js
function Person(name) {
  this.name = name;
}
var person = new Person('张三');
var p = Object.create(person); //对象p的原型为person
console.log(p); //Person {}

var __ptoto__ = Object.getPrototypeOf(p);
console.log(__ptoto__); //Person {name: "张三"}
```

#### 11. `Object.setPrototypeOf(obj,proto)`

功能: 设定目标对象的原型为另一个对象或 null,返回该目标对象

参数:

- obj(必须):目标对象
- proto(必须):原型对象

```js
var obj = { a: 1 };
var proto = {};
Object.setPrototypeOf(obj, proto);
proto.b = 2;
```

:::tip
Object.setPrototypeOf()方法的作用域**proto**相同,用来设置当前对象的原型指向的对象(prototype)。它是 ES6 正式推荐的设置原型对象方法
:::

#### 12. `Object.keys(obj)`

功能: 获取目标对象上所有的可枚举属性组成的数组
参数:

- obj(必须): 目标对象
  ::: tip
  Object.keys(obj)方法获取的集合和 for-in 遍历获取的不同在于，Object.keys()只获取目标对象上可枚举的自有属性，而 for-in 遍历会包含原型链上可枚举属性一并获取。

Object.keys()和 Object.getOwnPropertyNames()的相同之处都是获取目标对象的自有属性，区别在于，后者会连同不可枚举的自有属性也一并获取组成数组并返回。
:::

#### 13. `Object.preventExtensions(obj)/Object.isExtensible(obj)`

功能: 使某一对象不可扩展,也就是不能为其添加新属性

参数: obj(必填):目标对象
:::tip
Object.isExtensible(obj)方法用于判断一个对象是否可以扩展,是否可以添加新属性
:::

```js
var obj = { name: '张三' };
Object.preventExtensions(obj); //阻止obj的可扩展性
Object.isExtensible(obj); //false
obj.age = 23;
obj.name; //undefined
```

## Array 类型

### Array 对象属性

#### 1. length

设置或返回数组中元素的数目
:::tip
设置 length 属性可改变数组的大小如果设置的值比当前值小，数组将会被截断，其尾部的数组将丢失。如果设置的值比它的当前值要大，数组将增大，新的元素被添加到数组的尾部，他们的值为 undefined
:::

#### 2. constructor

返回创建此数组的数组函数的引用

#### 3. prototype

使您有能力向对象添加属性和方法

### 对象方法

#### 1. `concat()`

- 用于连接两个或多个数组,**此方法不会改变现有的数组**, 而是返回被连接数组的一个副本
- 如果要进行`concat()`操作的参数是数组,那么添加的是数组中的元素,而不是数组。

#### 2. `join()`

- 把数组中的所有元素放入一个字符串,元素是通过指定的分隔符进行分隔的
- 若省略了分隔符参数,则用逗号作为分隔符

#### 3.`push()`

- 向数组的末尾添加一个或多个元素，并返回新的数组长度

#### 4. `pop()`

- 用于删除数组的最后元素, 并返回被删除元素
- 如果数组已经为空,则 pop()不改变数组,并返回 undefined

#### 5.`shift()`

- 删除数组的第一个元素,并且返回被删除的这个元素
- 如果数组是空的,那么 shift()方法将不进行任何操作,返回 undefined

#### 6. `unshift()`

- 向数组的开头添加一个或多个元素,返回新的数组的长度

#### 7. `reverse()`

- 颠倒数组中元素的顺序

#### 8. `sort()`

- 对数组的元素进行排序
- **直接修改数组**
- 该方案接受一个可选参数,如未使用参数,则按字母顺序对数组元素进行排序(按照字符串编码的顺序进行排序)
- 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：
  - 若 a 小于 b，排序后 a 应该在 b 之前，则返回一个小于 0 的值。
  - 若 a 等于 b，则返回 0。
  - 若 a 大于 b，则返回一个大于 0 的值。

#### 9. `slice(start[,end])`

- 截取原数组从 start 到 end 位置(不包含它)元素组成的子数组
- **该方法返回一个新数组**,不修改原数组
- 若未指定 end 参数,那么截取尾巴直到原数组的最后一个元素(包含它)

#### 10. splice(index,howmany[,item1,item2...])

- 删除从 index 处开始的 hownamy 个元素，并且用可选参数列表中声明的一个或多个值来替换那些被删除的元素。
- 该方法返回的是含有被删除的元素组成的数组，若无被删元素，则返回空数组。
- 若参数只有 index，那么原数组将从 index 开始删除直至结尾。
- 该方法直接修改原数组。

#### 查找

##### 11. `find(fn)`

查找出数组中第一个符合条件的元素，若有多个符合条件的元素，则返回第一个元素

参数

- 回调函数接受三个参数,依次为当前的值、当前的位置和原数组
- thisArg（可选）：指定回调函数中的 this 值

  :::tip
  数组空位处理为 undefined
  :::

```js
[1, 5, 10, 15].find(function(value, index, arr) {
  return value > 9;
}); //10
```

##### 12.`findIndex(fn,thisArg)`

- 查找数组中符合条件的元素索引，若有多个符合条件的元素，则返回第一个元素索引
  参数：

- fn 回调函数
- thisArg（可选）：指定回调函数中的 this 值
  :::tip
  数组空位处理为 -1
  :::

#### 填充

##### 13. `fill()`

将一定范围索引的数组元素内容填充为单个指定的值

参数:

- 用来填充的 zhi
- 被填充的起始索引
- (可选):被填充的结束索引，默认为数组末尾

```js
let arr = Array.of(1, 2, 3, 4);
console.log(arr.fill(0, 1, 2)); // [1,0,3,4]
```

#### 14. copyWithin()

将一定范围所应得数组元素修改为此数组另一指定范围索引的元素

参数:

- 被修改的起始索引
- 被用来覆盖的数据的起始索引
- (可选): 被用来覆盖的数据的结束索引,默认为数据末尾

```js
console.log([1, 2, 3, 4].copyWithin(0, 2, 4)); // [3,4,3,4]
// 参数1为负数表示倒数
console.log([1, 2, 3, 4].copyWithin(-2, 0)); // [1,2,1,2]
console.log([1, 2, , 4].copyWithin(0, 2, 4)); // [, 4, , 4]
```

#### 遍历

##### 15. `entries()`

遍历键值对

```js
for (let [key, value] of ['a', 'b'].entries()) {
  console.log(key, value);
}
// 0 "a"
// 1 "b"

// 不使用 for... of 循环
let entries = ['a', 'b'].entries();
console.log(entries.next().value); // [0, "a"]
console.log(entries.next().value); // [1, "b"]
// 数组含空位
console.log([...[, 'a'].entries()]); // [[0, undefined], [1, "a"]]
```

##### 16. `keys()`

遍历键名,返回一个数组

##### 17. `values()`

遍历键值。

#### 包含

##### 18. includes()

数组是否包含指定值

参数:

- 包含指定值
- (可选)搜索的起始索引，默认为 0
  :::warning
  与 Set 和 Map 的 has 方法区分；Set 的 has 方法用于查找值;Map 的 has 方法用于查找键名
  :::

```js
[1,NaN，3].includes(NaN) //true
```

#### 嵌套数组转一维数组

##### 19. flat()

参数

- 指定转换的嵌套层数,默认是 1

```js
console.log([1, [2, , 3]].flat());
console.log([1, [2, [3, [4, 5]]]].flat(Infinity)); // [1, 2, 3, 4, 5]
```

##### 20. flatMap()

先对数组中每个元素进行了的处理,再对数组执行 flat()方法

参数:

- 遍历函数，该遍历函数可接受 3 个参数：当前元素、当前元素索引、原数组
- 指定遍历函数中 this 的指向

```js
console.log([1, 2, 3].flatMap(n => n * 2));
```

map(): 返回一个新的 Array,每个元素为调用 func 的结果
filter(): 返回一个符合 func 条件的元素数组
some(): 返回一个 boolean,判断是否有元素复合 func 的条件
every(): 返回一个 boolean, 判断每个元素是否符合 func 条件
forEach(): 没有返回值,只针对每个元素调用 func
reduce(): reduce 方法有两个参数，第一个参数是 callback，用于针对数组项的操作；第二个参数则是传入的初始值，这个初始值用于单个数组项的操作。需要注意的是，reduce 方法返回值并不是数组，而是形如初始值的经过叠加之后的操作。

### 实例方法

#### `Array.of()`

将一组值作为元素转化为数组

```js
Array.of(3, 11, 8); // [3,11,8]
Array.of(3); //[3]
```

这个函数的主要目的,是弥补数组构造函数 Array()的不足。因为参数个数不同，会导致 Array()的行为有差异

```js
Array(); //[]
Array(3); // [undefined,undefined,undefined]
Array(3, 11, 8); // [3,11,8]//当参数个数不小于两个时,Array()才会返回由参数组成的新数组
```

#### `Array.from(arrayLike[,mapFn[,thisArg]])`

将类数组对象（array-like object）或可迭代对象（iterable）转化成数组

参数:

- arrayLike(必填):想要转换的内数组或可迭代对象
- mapFn(可选)map 函数,用于对每个元素进行处理,放入数组的是处理后的元素
- thisArg(可选)用于指定 map 函数执行的 this 对象

```js
let map = {
  do: function(n) {
    return n * 2;
  }
};
let arrayLike = [1, 2, 3];
console.log(
  Array.from(
    arrayLike,
    function(n) {
      return this.do(n);
    },
    map
  )
); // [2,4,6]
```

## Date 类型

Date 对象: 封装一个时间点,提供操作时间的 API, Date 对象中封装的是从 1970 年 1 月 1 日 0 点至今的毫秒数

### 创建 Date 对象 4 种方式

#### new Date()

```js
let now = new Date(); // 获取客户端的当前系统时间
```

#### new Date(year,month, ...)

根据指定的日期时刻来创建 Date 对象；传入的参数按顺序依次是:年、月、日、小时、分钟、秒、毫秒。而这些参数都是可以缺省的
:::warning
当 new Date()只接收一个参数时,则接收的不是年,而是毫秒,针对 1970 年 1 月 1 日北京时间上午 8 点整开始计数(用**UTC 时间**来算，就是 1970 年 1 月 1 日 0 点 0 分 0 秒)
:::

```js
var d7 = new Date(2099); // 不是年,而是毫秒
```

:::warning
一个到十二月份是由 0~11 来代表的,0 代表一月份，11 代表十二月份
当代表年的参数时 1 位数或 2 位数是,则自动代表**19XX**,和自动加上 1900 没啥两样,一般来说不会触发,但还是知道 Date 构造器的这种特性为佳
:::

```js
var d1 = new Date(97, 6, 1); //代表1997年7月1日
var d2 = new Date(1, 0, 1); //代表1901年1月1日
```

#### new Date(dateString)

```js
let d1 = new date('1994/02/04 03:23:55'); //创建自定义事件
let d2 = new Date('October 1, 2018 11:11:11');
let d3 = new Date('1997-11-28'); // ISO Date 国际标准
let d4 = new Date('04/19/2099'); // short Date
let d5 = new Date('April 19 2099'); // 等同于"19 April 2099"
```

#### new Date(new Date(...))

```js
let oldDate = new Date('1994/02/04');
let newDate = new Date(oldDate); // 复制一个时间对象
```

### Date 对象的输出

Date 对象的输出,常用如以下三种方式

#### `toString()`: 输出是默认自动使用此方法

toString()方法(等价于默认下直接赋值对象本身), 输出类似`Fri Apr 10 2020 17:11:16 GMT+0800 (中国标准时间)`

#### `toUTCString()`

输出类似`Fri, 10 Apr 2020 09:13:09 GMT`

#### toDateString()

输出类似`2020/4/10 下午5:14:51`

### Date 对象 - Get 方法

- getFullYear()方法 - 获取代表年份的四位数字（yyyy）
- getMonth()方法 - 获取代表月份的数字（0~11）
- getDate()方法 - 获取代表当月几号的数字（1~31）
- getHours()方法 - 获取代表小时的数字（0~23）
- getMinutes()方法 - 获取代表分钟的数字（0~59）
- getSeconds()方法 - 获取代表秒的数字（0~59）
- getTime()方法 - 获取时间戳数字（以毫秒计算距离 utc 时间 1970 年 1 月 1 日 0 点 0 分 0 时的时间差）
- getDay()方法 - 获取代表周几的数字（0~6）
- getMilliseconds()方法 - 获取代表毫秒的数字（0~999）
- Date.now()方法 - 获取代表当前时间的时间戳数字
  ::: tip
  若使用 UTC 日期与事件,在 get 和具体的后缀词之间加上 UTC 即可,常用的方法有: `getUTCDate()`、getUTCDay()`、`getUTCFullYear()`、`getUTCHours()`、`getUTCMinutes()`、`getUTCMonth()`、`getUTCSeconds()`、`getUTCMilliseconds()`
  :::

### Date 对象 - Set 方法

- setFullYear()方法 - 设置年份信息（yyyy）
- setMonth()方法 - 设置月份的数字（0~11）
- setDate()方法 - 设置代表当月几号的数字（1~31）
- setHours()方法 - 设置代表小时的数字（0~23）
- setMinutes()方法 - 设置代表分钟的数字（0~59）
- setSeconds()方法 - 设置代表秒的数字（0~59）
- setMilliseconds()方法 - 设置代表毫秒的数字（0~999）
- setTime() - 设置时间戳数字信息（以毫秒计算距离 utc 时间 1970 年 1 月 1 日 0 点 0 分 0 时的时间差）
  ::: tip
  若使用 UTC 日期与事件,在 set 和具体的后缀词之间加上 UTC 即可,常用的方法有: `setUTCDate()`、setUTCDay()`、`setUTCFullYear()`、`setUTCHours()`、`setUTCMinutes()`、`setUTCMonth()`、`setUTCSeconds()`、`setUTCMilliseconds()`
  :::

## RegExp 类型

正则表达式（Regular Expression）是一种对字符串操作的逻辑公式，其描述的是一种**字符串匹配的模式（Pattern）**；根据这种匹配模式，可对字符串进行诸如：搜索子串、替换子串、验证字符串是否符合指定匹配模式等操作。

### 语法

`/正则表达式(pattern)/修饰符(modifiers,非必选)`

### 修饰符

| 修饰符 | 说明                                                  |
| ------ | ----------------------------------------------------- |
| `i`    | 执行匹配过程中,**忽略大小写的区别**                   |
| `g`    | 执行全局匹配(找到所有匹配,而非找到第一个匹配后就停止) |
| `m`    | 执行**多行匹配**                                      |
### RegExp对象方法
#### 1. `compile()`
- 用于在脚本执行过程中编译正则表达式
- 改变和重新编译正则表达式
#### 2.`exec()`
- 功能: 用于检索字符串中的正则表达式的匹配
- 参数: String(必填)要检索的字符串
- 返回值: 返回一个数组, 其中存放的匹配的结果。如果没有找到匹配，则返回值为null
#### 3. `test()`
 - 功能: 用于检测一个字符串是否匹配某个模式
 - 参数: string(必填)要检索的字符串
 - 返回值: true或者false
 ::: tip
 支持正则表达式的String对象的方法有: `search()`、`match()`、`replace()`和`split()`
 :::
 ## Function类型
 ### Function对象属性
 #### 1. `arguments`
- arguments.length：获取函数实参的个数
- arguments.callee：获取函数对象本身的引用
- arguments.callee.length：获取函数形参的个数
:::tip
JavaScript中每个函数都会有一个Arguments对象实例arguments，它引用着函数的实参，可以用数组下标的方式引用每个始计传入的值
:::