---
title: 闭包
date: 2020-03-24
tags:
  - Js
  - 基础
categories:
  - category1
---

#### 如何产生闭包

当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时,就产生了闭包

#### 闭包到底是什么

> 用 chrome 可以查看

- 理解一: 闭包是嵌套的内部函数(绝大多数人)
- 理解二:包含被引用变量(函数)的对象(极少数人)
- 注意: 闭包存在于嵌套的内部函数中

#### 产生闭包的条件

- 函数嵌套
- 内部函数引用了外部函数的数据
  - **执行内部函数定义就会产生闭包(不用调用函数)**

> 虽然引入变量也能产生闭包,但是不能产生实际效果。

#### 常见的闭包

1. 将函数作为另一个函数的返回值

2. 将函数作为实参传递给另一个函数调用

   1. ```js
      function showDelay(msg, time) {
        setTimeout(function() {
          alert(msg);
        }, time);
      }
      ```

#### 闭包的作用

1. 使用函数内部的变量在执行函数之后,仍然存活在内存中(延长了局部变量的生命周期)

2. 让函数外部可以操作(读写)到函数内部的变量(变量/函数)

   **问题:**

   1. 函数执行完后，函数内部声明的局部变量是否还存在？

      - 一般不存在，存在于闭包中的变量才可能存在

#### 闭包的生命周期

1. 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用的时候)
2. 死亡: 在嵌套的内部函数成为垃圾对象时

#### 闭包的应用:定义`js`模块

- 具有特定功能的`js`文件

- 将所有的数据和功能封装在一个函数内部(私有的)

- 只向外暴露一个包含 n 个方法的对象或函数

- 模块的使用者,只需要通过模块暴露的对象调用方法

  **最优应用**

  ```js
  (function(window) {
    //防止后面向外暴露方法的window被压缩
    //私有数据
    var msg = 'My atguigu';
    //操作数据的函数
    function doSomething() {
      console.log('doSomething()' + msg.toUpperCase());
    }
    function doOtherthing() {
      console.log('doOtherthing()' + msg.toLowerCase());
    }
    window.mymodule = {
      // 向外暴露对象(给外部使用的方法)
      doSomething: doSomething,
      doOtherthing: doOtherthing
    };
  })();
  ```

#### 闭包的缺点及解决

1. 缺点
   1. 函数执行完后，函数内的局部变量没有释放，占用内存时间会变长
   2. 容易造成内存泄漏
2. 解决
   1. 能不用就不用闭包
   2. 及时释放`f =null`//让内部函数成为垃圾对象-->回收闭包

##### 内存溢出与内存泄漏

1. 内存溢出
   - 一种程序运行出现的错误
   - 当程序运行需要的内存超过了剩余的内存时,就抛出内存溢出的错误
2. 内存泄漏
   - 占用的内存没有及时释放
   - 内存泄漏积累多了就容易导致内存溢出
   - 常见的内存泄漏
     - 意外的全局变量
     - 没有及时清理的计时器或回调函数
     - 闭包

#### 两种垃圾回收策略

找出那些不再继续使用的变量，然后释放其内存。垃圾回收器会按照固定的时间间隔，周期性的执行该垃圾回收操作。

共有两种策略：

- **标记清除法**
- **引用计数法**

##### 标记清除法

垃圾回收器会在运行的时候，会给存储在内存中的所有变量都加上标记，然后它会去掉环境中变量以及被环境中的变量引用的变量的标记。剩下的就视为即将要删除的变量，原因是在环境中无法访问到这些变量了。最后垃圾回收器完成内存清除操作。

**它的实现原理就是通过判断一个变量是否在执行环境中被引用，来进行标记删除。**

##### 引用计数法

引用计数的垃圾收集策略不常用，引用计数的最基本含义就是跟踪记录每个值被引用的次数。

当声明变量并将一个引用类型的值赋值给该变量时，则这个值的引用次数加 1，同一值被赋予另一个变量，该值的引用计数加 1 。当引用该值的变量被另一个值所取代，则引用计数减 1，当计数为 0 的时候，说明无法在访问这个值了，所有系统将会收回该值所占用的内存空间。

**存在的缺陷：**

两个对象的相互循环引用，在函数执行完成的时候，两个对象相互的引用计数并未归 0 ，而是依然占据内存，无法回收，当该函数执行多次时，内存占用就会变多，导致大量的内存得不到回收。

> 最常见的就是在 IE BOM 和 DOM 中，使用的对象并不是 js 对象，所以垃圾回收是基于计数策略的。但是在 IE9 已经将 BOM 和 DOM 真正的转化为了 js 对象，所以循环引用的问题得到解决。

#### 如何管理内存

虽然说是 `js` 的内存都是自动管理的，但是对于 `js` 还是存在一些问题的，最主要的一个问题就是**分配给 Web 浏览器的可用内存数量通常比分配给桌面应用程序的少**。

> 为了能够让页面获得最好的性能，必须确保 js 变量占用最少的内存，最好的方式就是将不用的变量引用释放掉，也叫做**解除引用**。

- 对于局部变量来说，函数执行完成离开环境变量，变量将自动解除。
- 对于全局变量我们需要进行手动解除。（注意：解除引用并不意味被收回，而是将变量真正的脱离执行环境，下一次垃圾回收将其收回）

> 补充：因为通过上边的垃圾回收机制的标记清除法的原理得知，只有与环境变量失去引用的变量才会被标记回收，所用上述例子通过将对象的引用设置为 null ，此变量也就失去了引用，等待被垃圾回收器回收。
